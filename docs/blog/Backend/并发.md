---
title: 并发优化
tags:
 - 并发优化
createTime: 2025/11/15 20:45:40
permalink: /blog/并发/
---

# 并发优化

## Redis缓存 + singleflight

**优化外部IO，减少DB查询**

### 场景问题

**高并发查询相同数据**：

- 1000个请求同时查询"用户ID=123"的信息
- 如果只用Redis，缓存失效瞬间，1000个请求都会打到数据库
- 这就是**缓存击穿**问题

### 问题拆解

```
请求1 → 查Redis → 没有 → 查DB → 返回
请求2 → 查Redis → 没有 → 查DB → 返回
请求3 → 查Redis → 没有 → 查DB → 返回
...（同时发生）
```

结果：同一个数据被查询了1000次

### 解决方案思路

**Singleflight的核心理念**： "既然1000个请求要的是同一个数据，那就只让第一个请求真正去查，其他999个等着共享结果"

### 实现流程

```
1. 请求1到达 → 查Redis未命中 → singleflight发现没人在查 → 标记"正在查询" → 去DB查
2. 请求2到达 → 查Redis未命中 → singleflight发现有人在查同样的key → 等待
3. 请求3到达 → 查Redis未命中 → singleflight发现有人在查同样的key → 等待
...
4. 请求1拿到DB结果 → 写入Redis → 返回给自己 → **同时**广播给所有等待的请求
5. 请求2-1000 → 直接拿到共享的结果 → 返回
```

### 解决了什么

- DB查询从1000次降到1次
- 保护了数据库不被瞬时高并发压垮
- 所有请求都能拿到数据，只是稍微等待了一下

------

## sync.Pool 复用对象

**优化内存管理，减少GC**

### 场景问题

**频繁创建销毁对象导致GC压力**：

- 每次HTTP请求都要创建Response对象、Buffer等
- 处理完就丢弃，等着GC回收
- 高并发下，每秒创建/销毁几万个对象

### 问题本质

```
请求1 → 创建对象A → 使用 → 丢弃 → GC回收
请求2 → 创建对象B → 使用 → 丢弃 → GC回收
请求3 → 创建对象C → 使用 → 丢弃 → GC回收
```

- 内存分配耗时
- GC频繁触发，影响性能（Stop The World）

### 解决方案思路

**对象池的理念**： "用完的对象别扔，洗干净放回池子，下次直接拿来用"

### 实现流程

```
1. 初始化：创建一个Pool
2. 请求1 → 从Pool.Get()拿对象 → 用完 → Pool.Put()还回去
3. 请求2 → 从Pool.Get()拿到请求1用过的对象 → 重置状态 → 使用 → 还回去
4. 请求3 → 从Pool.Get()拿对象 → ...
```

### 关键点

- **Get时**：池子有就拿，没有就临时创建
- **Put时**：对象要重置到初始状态（清空buffer、重置字段）
- **GC时**：Pool会被清空（Go的设计，防止内存泄漏）

### 解决了什么

- 减少内存分配次数
- 降低GC压力和频率
- 提升吞吐量